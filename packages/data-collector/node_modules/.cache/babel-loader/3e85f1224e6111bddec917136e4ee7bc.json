{"ast":null,"code":"export function formatDate(dateString, format, minValues = 10) {\n  let formattedDate = dateString;\n  const dateNumbers = dateString.map(date => new Date(date).getTime());\n  let domain = null;\n  let formatter = date => date.toISOString();\n  if (format === \"auto\") format = autoFormatDate(dateNumbers, minValues);\n  if (format === \"year\") formatter = date => date.getFullYear().toString();\n  if (format === \"quarter\") {\n    formatter = date => {\n      const year = date.getFullYear().toString();\n      const quarter = Math.floor(date.getMonth() / 3) + 1;\n      return `${year}-Q${quarter}`;\n    };\n  }\n  if (format === \"month\") {\n    formatter = date => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", {\n        month: \"short\"\n      });\n      return `${year}-${month}`;\n    };\n  }\n  if (format === \"day\") {\n    formatter = date => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", {\n        month: \"short\"\n      });\n      const day = date.getDate().toString();\n      return `${year}-${month}-${day}`;\n    };\n  }\n  if (format === \"hour\") {\n    formatter = date => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", {\n        month: \"short\"\n      });\n      const day = date.getDate().toString();\n      const hour = date.getHours();\n      return `${year}-${month}-${day} ${hour}:00`;\n    };\n  }\n  if (format === \"month_cycle\") {\n    formatter = date => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", {\n        month: \"long\"\n      });\n      return intlFormatter.format(date);\n    };\n    // can be any year, starting at january\n    domain = [new Date(\"2000-01-01\").getTime(), new Date(\"2001-01-01\").getTime()];\n  }\n  if (format === \"weekday_cycle\") {\n    formatter = date => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", {\n        weekday: \"long\"\n      });\n      return intlFormatter.format(date);\n    };\n    // can be any full week, starting at monday\n    domain = [new Date(\"2023-11-06\").getTime(), new Date(\"2023-11-13\").getTime()];\n  }\n  if (format === \"hour_cycle\") {\n    formatter = date => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", {\n        hour: \"numeric\",\n        hour12: false\n      });\n      return intlFormatter.format(date);\n    };\n    // can be any day, starting at midnight\n    domain = [new Date(\"2000-01-01\").getTime(), new Date(\"2000-01-02\").getTime()];\n  }\n  formattedDate = dateNumbers.map(date => formatter(new Date(date)));\n  if (domain == null) domain = getDomain(dateNumbers);\n  const sortableDate = createSortable(domain, format, formatter);\n  return [formattedDate, sortableDate];\n}\nfunction autoFormatDate(dateNumbers, minValues) {\n  const [minTime, maxTime] = getDomain(dateNumbers);\n  let autoFormat = \"hour\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * minValues) autoFormat = \"day\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * minValues) autoFormat = \"month\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * 3 * minValues) autoFormat = \"quarter\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 365 * minValues) autoFormat = \"year\";\n  return autoFormat;\n}\nfunction createSortable(domain, interval, formatter) {\n  // creates a map of datestrings to sortby numbers. Also includes intervalls, so that\n  // addZeroes can be used.\n  const sortable = {};\n  const [minTime, maxTime] = domain;\n\n  // intervalnumbers don't need to be exact. Just small enough that they never\n  // skip over an interval (e.g., month should be shortest possible month).\n  // Duplicate dates are ignored in set\n  let intervalNumber = 0;\n  if (interval === \"year\") intervalNumber = 1000 * 60 * 60 * 24 * 364;\n  if (interval === \"quarter\") intervalNumber = 1000 * 60 * 60 * 24 * 28 * 3;\n  if ([\"month\", \"month_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24 * 28;\n  if ([\"day\", \"weekday_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24;\n  if ([\"hour\", \"hour_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60;\n  if (intervalNumber > 0) {\n    for (let i = minTime; i <= maxTime; i += intervalNumber) {\n      const date = new Date(i);\n      const datestring = formatter(date);\n      if (sortable[datestring] !== undefined) continue;\n      sortable[datestring] = i;\n    }\n  }\n  return sortable;\n}\nfunction getDomain(numbers) {\n  let min = numbers[0];\n  let max = numbers[0];\n  numbers.forEach(nr => {\n    if (nr < min) min = nr;\n    if (nr > max) max = nr;\n  });\n  return [min, max];\n}\nexport function tokenize(text) {\n  const tokens = text.split(\" \");\n  return tokens.filter(token => /\\p{L}/giu.test(token)); // only tokens with word characters\n}\nexport function getTableColumn(table, column) {\n  if (column === \".COUNT\") {\n    // special case: just return array with values of 1\n    return Array(table.body.rows.length).fill(\"1\");\n  }\n  const columnIndex = table.head.cells.findIndex(cell => cell === column);\n  if (columnIndex < 0) throw new Error(`column ${table.id}.${column} not found`);\n  return table.body.rows.map(row => row.cells[columnIndex]);\n}\nexport function rescaleToRange(value, min, max, newMin, newMax) {\n  let scaled = (value - min) / (max - min);\n  scaled = isNaN(scaled) ? 0 : scaled; // prevent NaN\n  return scaled * (newMax - newMin) + newMin;\n}\nexport function extractUrlDomain(x) {\n  let domain;\n  try {\n    const url = new URL(x);\n    domain = url.hostname.replace(/^www\\./, \"\").replace(/^m\\./, \"\");\n  } catch (_) {\n    domain = x;\n  }\n  return domain.trim();\n}","map":{"version":3,"names":["formatDate","dateString","format","minValues","formattedDate","dateNumbers","map","date","Date","getTime","domain","formatter","toISOString","autoFormatDate","getFullYear","toString","year","quarter","Math","floor","getMonth","month","toLocaleString","day","getDate","hour","getHours","intlFormatter","Intl","DateTimeFormat","weekday","hour12","getDomain","sortableDate","createSortable","minTime","maxTime","autoFormat","interval","sortable","intervalNumber","includes","i","datestring","undefined","numbers","min","max","forEach","nr","tokenize","text","tokens","split","filter","token","test","getTableColumn","table","column","Array","body","rows","length","fill","columnIndex","head","cells","findIndex","cell","Error","id","row","rescaleToRange","value","newMin","newMax","scaled","isNaN","extractUrlDomain","x","url","URL","hostname","replace","_","trim"],"sources":["/home/turbo/d3i/projects/tim_reeskens/dd-instagram-tiu/packages/data-collector/src/components/consent_form_viz/visualization_plugin/visualizationDataFunctions/util.ts"],"sourcesContent":["import { DateFormat, Table } from \"../types\";\n\nexport function formatDate(\n  dateString: string[],\n  format: DateFormat,\n  minValues: number = 10\n): [string[], Record<string, number> | null] {\n  let formattedDate: string[] = dateString;\n  const dateNumbers = dateString.map((date) => new Date(date).getTime());\n  let domain: [number, number] | null = null;\n  let formatter: (date: Date) => string = (date) => date.toISOString();\n\n  if (format === \"auto\") format = autoFormatDate(dateNumbers, minValues);\n\n  if (format === \"year\") formatter = (date) => date.getFullYear().toString();\n\n  if (format === \"quarter\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const quarter = Math.floor(date.getMonth() / 3) + 1;\n      return `${year}-Q${quarter}`;\n    };\n  }\n\n  if (format === \"month\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      return `${year}-${month}`;\n    };\n  }\n\n  if (format === \"day\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      const day = date.getDate().toString();\n      return `${year}-${month}-${day}`;\n    };\n  }\n\n  if (format === \"hour\") {\n    formatter = (date) => {\n      const year = date.getFullYear().toString();\n      const month = date.toLocaleString(\"default\", { month: \"short\" });\n      const day = date.getDate().toString();\n      const hour = date.getHours();\n      return `${year}-${month}-${day} ${hour}:00`;\n    };\n  }\n\n  if (format === \"month_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { month: \"long\" });\n      return intlFormatter.format(date);\n    };\n    // can be any year, starting at january\n    domain = [new Date(\"2000-01-01\").getTime(), new Date(\"2001-01-01\").getTime()];\n  }\n  if (format === \"weekday_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { weekday: \"long\" });\n      return intlFormatter.format(date);\n    };\n    // can be any full week, starting at monday\n    domain = [new Date(\"2023-11-06\").getTime(), new Date(\"2023-11-13\").getTime()];\n  }\n  if (format === \"hour_cycle\") {\n    formatter = (date) => {\n      const intlFormatter = new Intl.DateTimeFormat(\"default\", { hour: \"numeric\", hour12: false });\n      return intlFormatter.format(date);\n    };\n    // can be any day, starting at midnight\n    domain = [new Date(\"2000-01-01\").getTime(), new Date(\"2000-01-02\").getTime()];\n  }\n\n  formattedDate = dateNumbers.map((date) => formatter(new Date(date)));\n  if (domain == null) domain = getDomain(dateNumbers);\n  const sortableDate: Record<string, number> | null = createSortable(domain, format, formatter);\n\n  return [formattedDate, sortableDate];\n}\n\nfunction autoFormatDate(dateNumbers: number[], minValues: number): DateFormat {\n  const [minTime, maxTime] = getDomain(dateNumbers);\n\n  let autoFormat: DateFormat = \"hour\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * minValues) autoFormat = \"day\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * minValues) autoFormat = \"month\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 30 * 3 * minValues) autoFormat = \"quarter\";\n  if (maxTime - minTime > 1000 * 60 * 60 * 24 * 365 * minValues) autoFormat = \"year\";\n\n  return autoFormat;\n}\n\nfunction createSortable(\n  domain: [number, number],\n  interval: string,\n  formatter: (date: Date) => string\n): Record<string, number> | null {\n  // creates a map of datestrings to sortby numbers. Also includes intervalls, so that\n  // addZeroes can be used.\n  const sortable: Record<string, number> = {};\n  const [minTime, maxTime] = domain;\n\n  // intervalnumbers don't need to be exact. Just small enough that they never\n  // skip over an interval (e.g., month should be shortest possible month).\n  // Duplicate dates are ignored in set\n  let intervalNumber: number = 0;\n  if (interval === \"year\") intervalNumber = 1000 * 60 * 60 * 24 * 364;\n  if (interval === \"quarter\") intervalNumber = 1000 * 60 * 60 * 24 * 28 * 3;\n  if ([\"month\", \"month_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24 * 28;\n  if ([\"day\", \"weekday_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60 * 24;\n  if ([\"hour\", \"hour_cycle\"].includes(interval)) intervalNumber = 1000 * 60 * 60;\n\n  if (intervalNumber > 0) {\n    for (let i = minTime; i <= maxTime; i += intervalNumber) {\n      const date = new Date(i);\n      const datestring = formatter(date);\n      if (sortable[datestring] !== undefined) continue;\n      sortable[datestring] = i;\n    }\n  }\n\n  return sortable;\n}\n\nfunction getDomain(numbers: number[]): [number, number] {\n  let min = numbers[0];\n  let max = numbers[0];\n  numbers.forEach((nr) => {\n    if (nr < min) min = nr;\n    if (nr > max) max = nr;\n  });\n  return [min, max];\n}\n\nexport function tokenize(text: string): string[] {\n  const tokens = text.split(\" \");\n  return tokens.filter((token) => /\\p{L}/giu.test(token)); // only tokens with word characters\n}\n\nexport function getTableColumn(table: Table, column: string): string[] {\n  if (column === \".COUNT\") {\n    // special case: just return array with values of 1\n    return Array(table.body.rows.length).fill(\"1\");\n  }\n  const columnIndex = table.head.cells.findIndex((cell) => cell === column);\n  if (columnIndex < 0) throw new Error(`column ${table.id}.${column} not found`);\n  return table.body.rows.map((row) => row.cells[columnIndex]);\n}\n\nexport function rescaleToRange(value: number, min: number, max: number, newMin: number, newMax: number): number {\n  let scaled = (value - min) / (max - min);\n  scaled = isNaN(scaled) ? 0 : scaled; // prevent NaN\n  return scaled * (newMax - newMin) + newMin;\n}\n\nexport function extractUrlDomain(x: string): string {\n  let domain;\n  try {\n    const url = new URL(x);\n    domain = url.hostname.replace(/^www\\./, \"\").replace(/^m\\./, \"\");\n  } catch (_) {\n    domain = x;\n  }\n  return domain.trim();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { formatDate, getTableColumn } from './util';\nexport async function prepareChartData(table, visualization) {\n  if (table.body.rows.length === 0) return {\n    type: visualization.type,\n    xKey: '',\n    xLabel: '',\n    yKeys: {},\n    data: []\n  };\n  const aggregate = aggregateData(table, visualization);\n  return createVisualizationData(table, visualization, aggregate);\n}\nfunction createVisualizationData(table, visualization, aggregate) {\n  const visualizationData = initializeVisualizationData(table, visualization);\n  visualizationData.data = Object.values(aggregate).sort((a, b) => a.sortBy < b.sortBy ? -1 : b.sortBy < a.sortBy ? 1 : 0).map(d => {\n    for (const key of Object.keys(d.values)) d.values[key] = Math.round(d.values[key] * 100) / 100;\n    return {\n      ...d.values,\n      [d.xKey]: d.xValue,\n      __rowIds: d.rowIds,\n      __sortBy: d.sortBy\n    };\n  });\n  return visualizationData;\n}\nfunction initializeVisualizationData(table, visualization) {\n  const yKeys = {};\n  for (const value of visualization.values) {\n    let tickerFormat = 'default';\n    if (value.aggregate === 'pct' || value.aggregate === 'count_pct') tickerFormat = 'percent';\n    if (value.group_by === undefined) {\n      const label = value.label !== undefined ? value.label : value.column;\n      yKeys[value.column] = {\n        id: value.column,\n        label,\n        tickerFormat\n      };\n    } else {\n      const uniqueValues = Array.from(new Set(getTableColumn(table, value.group_by)));\n      for (const uniqueValue of uniqueValues) {\n        const id = `${value.column}.GROUP_BY.${uniqueValue}`;\n        yKeys[id] = {\n          id,\n          label: uniqueValue,\n          tickerFormat\n        };\n      }\n    }\n  }\n  return {\n    type: visualization.type,\n    xKey: visualization.group.column,\n    xLabel: visualization.group.label,\n    yKeys,\n    data: []\n  };\n}\nfunction aggregateData(table, visualization) {\n  const aggregate = {};\n  const {\n    groupBy,\n    xSortable\n  } = prepareX(table, visualization);\n  const rowIds = table.body.rows.map(row => row.id);\n  const xKey = visualization.group.column;\n  const anyAddZeroes = visualization.values.some(value => value.addZeroes === true);\n  if (anyAddZeroes && xSortable != null) {\n    for (const [uniqueValue, sortby] of Object.entries(xSortable)) {\n      aggregate[uniqueValue] = {\n        sortBy: sortby,\n        rowIds: {},\n        xKey,\n        xValue: uniqueValue,\n        values: {}\n      };\n    }\n  }\n  for (const value of visualization.values) {\n    var _value$addZeroes;\n    // loop over all y values\n\n    const aggFun = value.aggregate !== undefined ? value.aggregate : 'count';\n    const yValues = getTableColumn(table, value.column);\n    if (yValues.length === 0) throw new Error(`Y column ${table.id}.${value.column} not found`);\n\n    // If group_by column is specified, the columns in the aggregated data will be the unique group_by\n    // column values. As suffix we use the value column, separated with .GROUP_BY.. This is used\n    // so that we can relate the aggregated data back to the value specification\n    let yGroup = null;\n    if (value.group_by !== undefined) {\n      yGroup = getTableColumn(table, value.group_by).map(v => `${value.column}.GROUP_BY.${v}`);\n    }\n\n    // if missing values should be treated as zero, we need to add the missing values after knowing all groups\n    const addZeroes = (_value$addZeroes = value.addZeroes) !== null && _value$addZeroes !== void 0 ? _value$addZeroes : false;\n    const groupSummary = {};\n    for (let i = 0; i < rowIds.length; i++) {\n      var _Number;\n      // loop over rows of table\n      const xValue = groupBy[i];\n      if (visualization.group.range !== undefined) {\n        if (Number(xValue) < visualization.group.range[0] || Number(xValue) > visualization.group.range[1]) {\n          continue;\n        }\n      }\n      const yValue = yValues[i];\n      const group = yGroup != null ? yGroup[i] : value.column;\n      const sortBy = xSortable != null ? xSortable[xValue] : groupBy[i];\n\n      // calculate group summary statistics. This is used for the mean, pct and count_pct aggregations\n      if (groupSummary[group] === undefined) groupSummary[group] = {\n        n: 0,\n        sum: 0\n      };\n      if (aggFun === 'count_pct' || aggFun === 'mean') groupSummary[group].n += 1;\n      if (aggFun === 'pct') groupSummary[group].sum += (_Number = Number(yValue)) !== null && _Number !== void 0 ? _Number : 0;\n      if (aggregate[xValue] === undefined) {\n        aggregate[xValue] = {\n          sortBy: sortBy,\n          rowIds: {},\n          xKey,\n          xValue: String(xValue),\n          values: {}\n        };\n      }\n      if (aggregate[xValue].rowIds[group] === undefined) aggregate[xValue].rowIds[group] = [];\n      aggregate[xValue].rowIds[group].push(rowIds[i]);\n      if (aggregate[xValue].values[group] === undefined) aggregate[xValue].values[group] = 0;\n      if (aggFun === 'count' || aggFun === 'count_pct') aggregate[xValue].values[group] += 1;\n      if (aggFun === 'sum' || aggFun === 'mean' || aggFun === 'pct') {\n        var _Number2;\n        aggregate[xValue].values[group] += (_Number2 = Number(yValue)) !== null && _Number2 !== void 0 ? _Number2 : 0;\n      }\n    }\n\n    // use groupSummary to calculate the mean, pct and count_pct aggregations\n    Object.keys(groupSummary).forEach(group => {\n      for (const xValue of Object.keys(aggregate)) {\n        if (aggregate[xValue].values[group] === undefined) {\n          if (addZeroes) aggregate[xValue].values[group] = 0;else continue;\n        }\n        if (aggFun === 'mean') {\n          aggregate[xValue].values[group] = Number(aggregate[xValue].values[group]) / groupSummary[group].n;\n        }\n        if (aggFun === 'count_pct') {\n          aggregate[xValue].values[group] = 100 * Number(aggregate[xValue].values[group]) / groupSummary[group].n;\n        }\n        if (aggFun === 'pct') {\n          aggregate[xValue].values[group] = 100 * Number(aggregate[xValue].values[group]) / groupSummary[group].sum;\n        }\n      }\n    });\n  }\n  return aggregate;\n}\nfunction prepareX(table, visualization) {\n  let groupBy = getTableColumn(table, visualization.group.column);\n  if (groupBy.length === 0) {\n    throw new Error(`X column ${table.id}.${visualization.group.column} not found`);\n  }\n  // let xSortable: Array<string | number> | null = null // separate variable allows using epoch time for sorting dates\n  let xSortable = null; // map x values to sortable values\n\n  // ADD CODE TO TRANSFORM TO DATE, BUT THEN ALSO KEEP AN INDEX BASED ON THE DATE ORDER\n  if (visualization.group.dateFormat !== undefined) {\n    ;\n    [groupBy, xSortable] = formatDate(groupBy, visualization.group.dateFormat);\n  }\n  if (visualization.group.levels !== undefined) {\n    xSortable = {};\n    for (let i = 0; i < visualization.group.levels.length; i++) {\n      const level = visualization.group.levels[i];\n      xSortable[level] = i;\n    }\n  }\n  return {\n    groupBy,\n    xSortable\n  };\n}","map":{"version":3,"names":["formatDate","getTableColumn","prepareChartData","table","visualization","body","rows","length","type","xKey","xLabel","yKeys","data","aggregate","aggregateData","createVisualizationData","visualizationData","initializeVisualizationData","Object","values","sort","a","b","sortBy","map","d","key","keys","Math","round","xValue","__rowIds","rowIds","__sortBy","value","tickerFormat","group_by","undefined","label","column","id","uniqueValues","Array","from","Set","uniqueValue","group","groupBy","xSortable","prepareX","row","anyAddZeroes","some","addZeroes","sortby","entries","_value$addZeroes","aggFun","yValues","Error","yGroup","v","groupSummary","i","_Number","range","Number","yValue","n","sum","String","push","_Number2","forEach","dateFormat","levels","level"],"sources":["/home/turbo/d3i/projects/tim_reeskens/dd-instagram-tiu/packages/data-collector/src/components/consent_form_viz/visualization_plugin/visualizationDataFunctions/prepareChartData.ts"],"sourcesContent":["import { formatDate, getTableColumn } from './util'\nimport { Table, TickerFormat, ChartVisualizationData, ChartVisualization, AxisSettings } from '../types'\n\nexport async function prepareChartData (\n  table: Table,\n  visualization: ChartVisualization\n): Promise<ChartVisualizationData> {\n  if (table.body.rows.length === 0) return { type: visualization.type, xKey: '', xLabel: '', yKeys: {}, data: [] }\n\n  const aggregate = aggregateData(table, visualization)\n  return createVisualizationData(table, visualization, aggregate)\n}\n\nfunction createVisualizationData (\n  table: Table,\n  visualization: ChartVisualization,\n  aggregate: Record<string, PrepareAggregatedData>\n): ChartVisualizationData {\n  const visualizationData = initializeVisualizationData(table, visualization)\n\n  visualizationData.data = Object.values(aggregate)\n    .sort((a: any, b: any) => (a.sortBy < b.sortBy ? -1 : b.sortBy < a.sortBy ? 1 : 0))\n    .map((d) => {\n      for (const key of Object.keys(d.values)) d.values[key] = Math.round(d.values[key] * 100) / 100\n\n      return {\n        ...d.values,\n        [d.xKey]: d.xValue,\n        __rowIds: d.rowIds,\n        __sortBy: d.sortBy\n      }\n    })\n\n  return visualizationData\n}\n\nfunction initializeVisualizationData (table: Table, visualization: ChartVisualization): ChartVisualizationData {\n  const yKeys: Record<string, AxisSettings> = {}\n  for (const value of visualization.values) {\n    let tickerFormat: TickerFormat = 'default'\n    if (value.aggregate === 'pct' || value.aggregate === 'count_pct') tickerFormat = 'percent'\n\n    if (value.group_by === undefined) {\n      const label = value.label !== undefined ? value.label : value.column\n      yKeys[value.column] = { id: value.column, label, tickerFormat }\n    } else {\n      const uniqueValues = Array.from(new Set(getTableColumn(table, value.group_by)))\n      for (const uniqueValue of uniqueValues) {\n        const id = `${value.column}.GROUP_BY.${uniqueValue}`\n        yKeys[id] = { id, label: uniqueValue, tickerFormat }\n      }\n    }\n  }\n\n  return {\n    type: visualization.type,\n    xKey: visualization.group.column,\n    xLabel: visualization.group.label,\n    yKeys,\n    data: []\n  }\n}\n\nfunction aggregateData (table: Table, visualization: ChartVisualization): Record<string, PrepareAggregatedData> {\n  const aggregate: Record<string, PrepareAggregatedData> = {}\n\n  const { groupBy, xSortable } = prepareX(table, visualization)\n  const rowIds = table.body.rows.map((row) => row.id)\n  const xKey = visualization.group.column\n\n  const anyAddZeroes = visualization.values.some((value) => value.addZeroes === true)\n  if (anyAddZeroes && xSortable != null) {\n    for (const [uniqueValue, sortby] of Object.entries(xSortable)) {\n      aggregate[uniqueValue] = {\n        sortBy: sortby,\n        rowIds: {},\n        xKey,\n        xValue: uniqueValue,\n        values: {}\n      }\n    }\n  }\n\n  for (const value of visualization.values) {\n    // loop over all y values\n\n    const aggFun = value.aggregate !== undefined ? value.aggregate : 'count'\n\n    const yValues = getTableColumn(table, value.column)\n    if (yValues.length === 0) throw new Error(`Y column ${table.id}.${value.column} not found`)\n\n    // If group_by column is specified, the columns in the aggregated data will be the unique group_by\n    // column values. As suffix we use the value column, separated with .GROUP_BY.. This is used\n    // so that we can relate the aggregated data back to the value specification\n    let yGroup: null | string[] = null\n    if (value.group_by !== undefined) { yGroup = getTableColumn(table, value.group_by).map((v) => `${value.column}.GROUP_BY.${v}`) }\n\n    // if missing values should be treated as zero, we need to add the missing values after knowing all groups\n    const addZeroes = value.addZeroes ?? false\n    const groupSummary: Record<string, { n: number, sum: number }> = {}\n\n    for (let i = 0; i < rowIds.length; i++) {\n      // loop over rows of table\n      const xValue = groupBy[i]\n\n      if (visualization.group.range !== undefined) {\n        if (Number(xValue) < visualization.group.range[0] || Number(xValue) > visualization.group.range[1]) {\n          continue\n        }\n      }\n\n      const yValue = yValues[i]\n      const group = yGroup != null ? yGroup[i] : value.column\n\n      const sortBy = xSortable != null ? xSortable[xValue] : groupBy[i]\n\n      // calculate group summary statistics. This is used for the mean, pct and count_pct aggregations\n      if (groupSummary[group] === undefined) groupSummary[group] = { n: 0, sum: 0 }\n      if (aggFun === 'count_pct' || aggFun === 'mean') groupSummary[group].n += 1\n      if (aggFun === 'pct') groupSummary[group].sum += Number(yValue) ?? 0\n\n      if (aggregate[xValue] === undefined) {\n        aggregate[xValue] = {\n          sortBy: sortBy,\n          rowIds: {},\n          xKey,\n          xValue: String(xValue),\n          values: {}\n        }\n      }\n\n      if (aggregate[xValue].rowIds[group] === undefined) aggregate[xValue].rowIds[group] = []\n      aggregate[xValue].rowIds[group].push(rowIds[i])\n\n      if (aggregate[xValue].values[group] === undefined) aggregate[xValue].values[group] = 0\n      if (aggFun === 'count' || aggFun === 'count_pct') aggregate[xValue].values[group] += 1\n      if (aggFun === 'sum' || aggFun === 'mean' || aggFun === 'pct') {\n        aggregate[xValue].values[group] += Number(yValue) ?? 0\n      }\n    }\n\n    // use groupSummary to calculate the mean, pct and count_pct aggregations\n    Object.keys(groupSummary).forEach((group) => {\n      for (const xValue of Object.keys(aggregate)) {\n        if (aggregate[xValue].values[group] === undefined) {\n          if (addZeroes) aggregate[xValue].values[group] = 0\n          else continue\n        }\n        if (aggFun === 'mean') {\n          aggregate[xValue].values[group] = Number(aggregate[xValue].values[group]) / groupSummary[group].n\n        }\n        if (aggFun === 'count_pct') {\n          aggregate[xValue].values[group] = (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].n\n        }\n        if (aggFun === 'pct') {\n          aggregate[xValue].values[group] = (100 * Number(aggregate[xValue].values[group])) / groupSummary[group].sum\n        }\n      }\n    })\n  }\n\n  return aggregate\n}\n\nfunction prepareX (\n  table: Table,\n  visualization: ChartVisualization\n): { groupBy: string[], xSortable: Record<string, string | number> | null } {\n  let groupBy = getTableColumn(table, visualization.group.column)\n  if (groupBy.length === 0) {\n    throw new Error(`X column ${table.id}.${visualization.group.column} not found`)\n  }\n  // let xSortable: Array<string | number> | null = null // separate variable allows using epoch time for sorting dates\n  let xSortable: Record<string, string | number> | null = null // map x values to sortable values\n\n  // ADD CODE TO TRANSFORM TO DATE, BUT THEN ALSO KEEP AN INDEX BASED ON THE DATE ORDER\n  if (visualization.group.dateFormat !== undefined) {\n    ;[groupBy, xSortable] = formatDate(groupBy, visualization.group.dateFormat)\n  }\n\n  if (visualization.group.levels !== undefined) {\n    xSortable = {}\n\n    for (let i = 0; i < visualization.group.levels.length; i++) {\n      const level = visualization.group.levels[i]\n      xSortable[level] = i\n    }\n  }\n\n  return { groupBy, xSortable }\n}\n\nexport interface PrepareAggregatedData {\n  xKey: string\n  xValue: string\n  values: Record<string, number>\n  rowIds: Record<string, string[]>\n  sortBy: number | string\n  tickerFormat?: TickerFormat\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}